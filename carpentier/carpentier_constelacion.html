<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Constelación — Alejo Carpentier</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; display:flex; height:100vh; }
    #viz { flex:1 1 auto; background:#fafafa; }
    #panel { width:340px; border-left:1px solid #e5e5e5; padding:16px; background:white; overflow:auto; }
    #panel h2 { font-size:18px; margin:0 0 6px; }
    #panel .meta { color:#666; font-size:12px; margin-bottom:8px; }
    #panel .ctx { white-space:pre-wrap; line-height:1.35; }

    .legend { position:absolute; left:10px; top:10px; background:rgba(255,255,255,.9); border:1px solid #e5e5e5; padding:8px; border-radius:6px; font-size:12px; }
    .search-box { position:absolute; right:360px; top:10px; background:white; border:1px solid #ccc; border-radius:6px; padding:4px; }

    .node { cursor:pointer; transition: opacity .2s ease; }
    .link { stroke:#bbb; stroke-opacity:.6; transition: opacity .2s ease; }
    .dimmed { opacity: .15; } /* CAMBIO: solo atenuar, sin resaltar */
  </style>
</head>
<body>
  <div id="viz"></div>
  <aside id="panel">
    <h2>Selecciona un nodo</h2>
    <div class="meta">Haz clic en una <strong>referencia</strong> para ver el contexto breve.</div>
    <div id="content" class="ctx">—</div>
  </aside>

  <div class="legend">
    <strong>Categorías</strong><br/>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:green;margin-right:4px;"></span> Pensamiento y conocimiento</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:purple;margin-right:4px;"></span> Contexto socio-histórico</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:red;margin-right:4px;"></span> Personales y biográficas</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:orange;margin-right:4px;"></span> Culturales y artísticas</div>
  </div>

  <div class="search-box">
    <input type="text" id="search" placeholder="Buscar referencia..." />
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const width = window.innerWidth - 340, height = window.innerHeight;

    // Colores por etiqueta de categoría (normalizado) y por ID canónico
    const categoryColorsExact = {
      "pensamiento y conocimiento": "green",
      "contexto socio-histórico": "purple",
      "contexto socio-historico": "purple",
      "personales y biográficas": "red",
      "personales y biograficas": "red",
      "culturales y artísticas": "orange",
      "culturales y artisticas": "orange"
    };
    const categoryColorsById = {
      "categoria_pensamiento_y_conocimiento": "green",
      "categoria_contexto_sociohistorico": "purple",
      "categoria_personales_y_biograficas": "red",
      "categoria_culturales_y_artisticas": "orange"
    };
    const blueRef = "#1f77b4";

    function norm(s){ return (s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().trim(); }
    function colorForCategory(d){
      const byLabel = categoryColorsExact[norm(d.label)];
      if (byLabel) return byLabel;
      if (d.id && categoryColorsById[d.id]) return categoryColorsById[d.id];
      const idn = norm(d.id||"");
      if (idn.includes("pensamiento") || idn.includes("conocimiento")) return "green";
      if (idn.includes("contexto") || idn.includes("socio") || idn.includes("histor")) return "purple";
      if (idn.includes("personal") || idn.includes("biogra")) return "red";
      if (idn.includes("cultur") || idn.includes("artist")) return "orange";
      return "#000";
    }
    function colorNode(d){
      if (d.type === "reference") return blueRef;
      if (d.type === "category") return colorForCategory(d);
      if (d.type === "author") return "#000";
      return "#999";
    }

    async function loadCsvSmart(url){
      const txt = await fetch(url, {cache:"no-store"}).then(r => {
        if(!r.ok) throw new Error(`HTTP ${r.status} al cargar ${url}`); return r.text();
      });
      const head = txt.split(/\r?\n/,1)[0] || "";
      const sep = (head.split(";").length > head.split(",").length) ? ";" : ",";
      return d3.dsvFormat(sep).parse(txt);
    }

    (async () => {
      try{
        let [nodes, links] = await Promise.all([
          loadCsvSmart("carpentier_nodos.csv"),
          loadCsvSmart("carpentier_aristas.csv")
        ]);

        const nodeById = new Map(nodes.map(d => [d.id, d]));
        links = links.filter(e => nodeById.has(e.source) && nodeById.has(e.target));
        links.forEach(e => { e.source = nodeById.get(e.source); e.target = nodeById.get(e.target); });

        // Nodo central autor
        const authorNode = { id:"autor", label:"Alejo Carpentier", type:"author" };
        nodes.push(authorNode);
        nodes.filter(n => n.type==="category").forEach(cat => links.push({source:authorNode, target:cat}));

        const svg = d3.select("#viz").append("svg").attr("width", width).attr("height", height);
        const g = svg.append("g");

        // Flechas
        svg.append("defs").selectAll("marker")
          .data(["arrow"]).join("marker")
          .attr("id","arrow").attr("viewBox","0 -5 10 10")
          .attr("refX",14).attr("refY",0)
          .attr("markerWidth",6).attr("markerHeight",6)
          .attr("orient","auto")
          .append("path").attr("d","M0,-5L10,0L0,5").attr("fill","#bbb");

        const link = g.append("g")
          .selectAll("line").data(links).join("line")
          .attr("class","link")
          .attr("stroke","#bbb").attr("stroke-opacity",0.6)
          .attr("marker-end","url(#arrow)");

        const node = g.append("g")
          .selectAll("circle").data(nodes).join("circle")
          .attr("class", d => "node " + d.type)
          .attr("r", d => d.type==="category" ? 20 : (d.type==="author" ? 30 : 8))
          .attr("fill", d => colorNode(d))
          .call(d3.drag()
            .on("start", (event,d) => { if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
            .on("drag",  (event,d) => { d.fx=event.x; d.fy=event.y; })
            .on("end",   (event,d) => { if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; })
          )
          .on("click", (event,d) => showPanel(d));

        const label = g.append("g")
          .selectAll("text").data(nodes).join("text")
          .text(d => d.label)
          .attr("dy", d => d.type==="category" ? -25 : (d.type==="author" ? -35 : -12))
          .attr("font-size", d => d.type==="category" ? 14 : (d.type==="author" ? 18 : 11))
          .attr("text-anchor","middle").attr("fill","#333");

        // Fuerzas
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d=>d.id).distance(l =>
            (l.source.type==="category" || l.target.type==="category") ? 130 : 90
          ).strength(0.35))
          .force("charge", d3.forceManyBody().strength(-280))
          .force("center", d3.forceCenter(width/2, height/2))
          .force("collision", d3.forceCollide().radius(d => d.type==="category" ? 42 : (d.type==="author" ? 52 : 18)).strength(0.9));

        simulation.on("tick", () => {
          link.attr("x1", d=>d.source.x).attr("y1", d=>d.source.y)
              .attr("x2", d=>d.target.x).attr("y2", d=>d.target.y);
          node.attr("cx", d=>d.x).attr("cy", d=>d.y);
          label.attr("x", d=>d.x).attr("y", d=>d.y);
        });

        // CAMBIO: zoom libre + fit inicial UNA ÚNICA VEZ con timeout (no ligado a zoom ni a end)
        const zoom = d3.zoom().scaleExtent([0.2, 2.2]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);

        // CAMBIO: fit inicial con más margen y cap de escala (0.85), sin reencuadres posteriores
        setTimeout(() => {
          const box = g.node().getBBox();
          if (box.width === 0 || box.height === 0) return;
          const margin = 120; // margen amplio
          const sx = (width  - margin) / box.width;
          const sy = (height - margin) / box.height;
          let k = Math.min(sx, sy);
          k = Math.min(k, 0.85); // cap para no acercar demasiado
          const tx = (width/2)  - k * (box.x + box.width/2);
          const ty = (height/2) - k * (box.y + box.height/2);
          svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
        }, 1200); // espera a que la simulación “asiente” un poco

        function showPanel(d){
          const panel = document.getElementById("content");
          if (d.type === "reference") {
            const ctx = (d.note && d.note.trim()) ? d.note : "Sin contexto breve disponible.";
            panel.innerHTML = `<strong>${escapeHtml(d.label||"Referencia")}</strong>\n\n${escapeHtml(ctx)}`;
          } else {
            panel.innerHTML = `<strong>${escapeHtml(d.label||"Categoría")}</strong>`;
          }
        }
        function escapeHtml(s){ return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

        // CAMBIO: búsqueda — solo atenuar NO coincidencias; matches quedan tal cual (sin amarillo)
        const searchInput = document.getElementById("search");
        searchInput.addEventListener("input", () => {
          const q = norm(searchInput.value);
          let firstMatch = null;

          // reset clases
          node.classed("dimmed", false);
          label.classed("dimmed", false);
          link.classed("dimmed", false);

          if (!q.length) return; // sin filtro, nada atenuado

          // marca qué referencias coinciden
          const matchSet = new Set();
          node.each(d => {
            const hit = (d.type === "reference") && norm(d.label).includes(q);
            if (hit) matchSet.add(d.id), (firstMatch ??= d);
          });

          // atenuar nodos que NO coinciden (salvo categorías y autor, que se mantienen)
          node.classed("dimmed", d =>
            d.type === "reference" ? !matchSet.has(d.id) : false
          );
          label.classed("dimmed", d =>
            d.type === "reference" ? !matchSet.has(d.id) : false
          );

          // atenuar links si ninguno de sus extremos es match
          link.classed("dimmed", e =>
            !(matchSet.has(e.source.id) || matchSet.has(e.target.id))
          );

          // centra en el primer match (si quieres desactivar el centrado, comenta estas 3 líneas)
          if (firstMatch) {
            const current = d3.zoomTransform(svg.node());
            const scale = Math.min(2.0, Math.max(0.9, current.k));
            const tx = (width/2)  - scale * firstMatch.x;
            const ty = (height/2) - scale * firstMatch.y;
            svg.transition().duration(450).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
          }
        });

        // texto inicial limpio
        document.getElementById("content").textContent = "—";

      }catch(err){
        document.getElementById("content").textContent = "Error cargando datos: " + err.message;
      }
    })();
  </script>
</body>
</html>
