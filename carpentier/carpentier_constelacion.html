<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Constelación — Alejo Carpentier</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; display:flex; height:100vh; }
    #viz { flex:1 1 auto; background:#fafafa; }
    #panel { width:340px; border-left:1px solid #e5e5e5; padding:16px; background:white; overflow:auto; }
    #panel h2 { font-size:18px; margin:0 0 6px; }
    #panel .meta { color:#666; font-size:12px; margin-bottom:8px; }
    #panel .ctx { white-space:pre-wrap; line-height:1.35; }

    .legend { position:absolute; left:10px; top:10px; background:rgba(255,255,255,.9); border:1px solid #e5e5e5; padding:8px; border-radius:6px; font-size:12px; }
    .search-box { position:absolute; right:360px; top:10px; background:white; border:1px solid #ccc; border-radius:6px; padding:4px; }

    .node { cursor:pointer; }
    .link { stroke:#bbb; stroke-opacity:.6; }
    .dimmed { opacity: 0.15; } /* CAMBIO: para atenuar */
    .highlight { stroke: yellow; stroke-width: 3; } /* CAMBIO: para resaltar */
  </style>
</head>
<body>
  <div id="viz"></div>
  <aside id="panel">
    <h2>Selecciona un nodo</h2>
    <div class="meta">Haz clic en una <strong>referencia</strong> para ver el contexto breve.</div>
    <div id="content" class="ctx">—</div>
  </aside>

  <!-- CAMBIO: leyenda EXACTA de tus categorías -->
  <div class="legend">
    <strong>Categorías</strong><br/>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:green;margin-right:4px;"></span> Pensamiento y conocimiento</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:purple;margin-right:4px;"></span> Contexto socio-histórico</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:red;margin-right:4px;"></span> Personales y biográficas</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:orange;margin-right:4px;"></span> Culturales y artísticas</div>
  </div>

  <!-- CAMBIO: caja de búsqueda funcional -->
  <div class="search-box">
    <input type="text" id="search" placeholder="Buscar referencia..." />
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const width = window.innerWidth - 340, height = window.innerHeight;

    // CAMBIO: mapeo EXACTO de colores por label
    const categoryColorsExact = {
      "pensamiento y conocimiento": "green",
      "contexto socio-histórico": "purple",
      "contexto socio-historico": "purple",   // por si el CSV viniera sin tilde
      "personales y biográficas": "red",
      "personales y biograficas": "red",
      "culturales y artísticas": "orange",
      "culturales y artisticas": "orange"
    };
    // CAMBIO: mapeo por id "canónico" por si tus CSV usan ids estables
    const categoryColorsById = {
      "categoria_pensamiento_y_conocimiento": "green",
      "categoria_contexto_sociohistorico": "purple",
      "categoria_personales_y_biograficas": "red",
      "categoria_culturales_y_artisticas": "orange"
    };
    const blueRef = "#1f77b4";

    // CAMBIO: normalizador (quita tildes y pasa a minúsculas)
    function norm(s) {
      if (!s) return "";
      return s.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().trim();
    }

    function colorForCategory(d) {
      // intenta por label exacto (normalizado)
      const byLabel = categoryColorsExact[norm(d.label)];
      if (byLabel) return byLabel;
      // intenta por id exacto
      if (d.id && categoryColorsById[d.id]) return categoryColorsById[d.id];
      // heurística por palabras clave en id (último recurso)
      const idn = norm(d.id || "");
      if (idn.includes("pensamiento") || idn.includes("conocimiento")) return "green";
      if (idn.includes("contexto") || idn.includes("socio") || idn.includes("histor")) return "purple";
      if (idn.includes("personal") || idn.includes("biogra")) return "red";
      if (idn.includes("cultur") || idn.includes("artist")) return "orange";
      return "#000";
    }

    function colorNode(d) {
      if (d.type === "reference") return blueRef;
      if (d.type === "category") return colorForCategory(d); // CAMBIO: categorías coloreadas
      if (d.type === "author") return "#000";
      return "#999";
    }

    async function loadCsvSmart(url) {
      const txt = await fetch(url, { cache: "no-store" }).then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status} al cargar ${url}`);
        return r.text();
      });
      const header = txt.split(/\r?\n/,1)[0] || "";
      const sep = (header.split(";").length > header.split(",").length) ? ";" : ",";
      return d3.dsvFormat(sep).parse(txt);
    }

    (async () => {
      try {
        let [nodes, links] = await Promise.all([
          loadCsvSmart("carpentier_nodos.csv"),
          loadCsvSmart("carpentier_aristas.csv")
        ]);

        // Filtrado de aristas inválidas y objeto de acceso rápido
        const nodeById = new Map(nodes.map(d => [d.id, d]));
        links = links.filter(e => nodeById.has(e.source) && nodeById.has(e.target));
        links.forEach(e => { e.source = nodeById.get(e.source); e.target = nodeById.get(e.target); });

        // CAMBIO: nodo central autor → conectado a TODAS las categorías
        const authorNode = { id: "autor", label: "Alejo Carpentier", type: "author" };
        nodes.push(authorNode);
        nodes.filter(n => n.type === "category").forEach(cat => {
          links.push({ source: authorNode, target: cat });
        });

        const svg = d3.select("#viz").append("svg").attr("width", width).attr("height", height);
        const g = svg.append("g");

        // Flechas
        svg.append("defs").selectAll("marker")
          .data(["arrow"]).join("marker")
          .attr("id", "arrow").attr("viewBox", "0 -5 10 10")
          .attr("refX", 14).attr("refY", 0)
          .attr("markerWidth", 6).attr("markerHeight", 6)
          .attr("orient", "auto")
          .append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", "#bbb");

        const link = g.append("g")
          .selectAll("line").data(links).join("line")
          .attr("class", "link")
          .attr("stroke", "#bbb").attr("stroke-opacity", 0.6)
          .attr("marker-end", "url(#arrow)");

        const node = g.append("g")
          .selectAll("circle").data(nodes).join("circle")
          .attr("class", d => "node " + d.type)
          .attr("r", d => d.type==="category" ? 20 : (d.type==="author" ? 30 : 8))
          .attr("fill", d => colorNode(d))
          .call(d3.drag()
            .on("start", (event,d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
            .on("drag",  (event,d) => { d.fx = event.x; d.fy = event.y; })
            .on("end",   (event,d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; })
          )
          .on("click", (event, d) => showPanel(d));

        const label = g.append("g")
          .selectAll("text").data(nodes).join("text")
          .text(d => d.label)
          .attr("dy", d => d.type==="category" ? -25 : (d.type==="author" ? -35 : -12))
          .attr("font-size", d => d.type==="category" ? 14 : (d.type==="author" ? 18 : 11))
          .attr("text-anchor", "middle")
          .attr("fill", "#333");

        // Fuerzas: más separación desde categorías + colisión fuerte
        const simulation = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d => d.id).distance(l => {
            return (l.source.type === "category" || l.target.type === "category") ? 130 : 90;
          }).strength(0.35))
          .force("charge", d3.forceManyBody().strength(-280))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(d => d.type==="category" ? 42 : (d.type==="author" ? 52 : 18)).strength(0.9));

        simulation.on("tick", () => {
          link
            .attr("x1", d => d.source.x).attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
          node.attr("cx", d => d.x).attr("cy", d => d.y);
          label.attr("x", d => d.x).attr("y", d => d.y);
        });

        // CAMBIO: zoom + pan; fit SOLO una vez al final
        const zoom = d3.zoom().scaleExtent([0.2, 2.2]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);
        let fitted = false; // CAMBIO: evita autofit tras clic
        simulation.on("end", () => {
          if (fitted) return;
          const box = g.node().getBBox();
          if (box.width === 0 || box.height === 0) return;

          const margin = 60;
          const sx = (width - margin) / box.width;
          const sy = (height - margin) / box.height;
          let k = Math.min(sx, sy);
          // CAMBIO: limita el zoom inicial a no pasar de 1.0 (que no “meta demasiado”)
          k = Math.min(k, 1.0) * 0.95;

          const translateX = (width / 2) - k * (box.x + box.width / 2);
          const translateY = (height / 2) - k * (box.y + box.height / 2);

          const t = d3.zoomIdentity.translate(translateX, translateY).scale(k);
          svg.transition().duration(500).call(zoom.transform, t).on("end", () => { fitted = true; });
        });

        function showPanel(d) {
          const panel = document.getElementById("content");
          if (d.type === "reference") {
            const ctx = (d.note && d.note.trim()) ? d.note : "Sin contexto breve disponible.";
            panel.innerHTML = `<strong>${escapeHtml(d.label || "Referencia")}</strong>\n\n${escapeHtml(ctx)}`;
          } else {
            panel.innerHTML = `<strong>${escapeHtml(d.label || "Categoría")}</strong>`;
          }
        }
        function escapeHtml(s) { return (s || "").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

        // CAMBIO: búsqueda — resalta y centra el 1er match, atenúa el resto
        const searchInput = document.getElementById("search");
        searchInput.addEventListener("input", () => {
          const q = norm(searchInput.value);
          let firstMatch = null;

          node.classed("highlight", false);
          label.classed("highlight", false);
          node.classed("dimmed", q.length > 0);
          label.classed("dimmed", q.length > 0);

          node.each(function(d) {
            const hit = (d.type === "reference") && norm(d.label).includes(q) && q.length > 0;
            if (hit && !firstMatch) firstMatch = d;
            d3.select(this).classed("highlight", hit).classed("dimmed", q.length>0 && !hit);
          });
          label.each(function(d) {
            const hit = (d.type === "reference") && norm(d.label).includes(q) && q.length > 0;
            d3.select(this).classed("highlight", hit).classed("dimmed", q.length>0 && !hit);
          });

          // centra en el primer match (si existe)
          if (firstMatch) {
            const scale = Math.min(2.0, Math.max(0.9, d3.zoomTransform(svg.node()).k));
            const tx = (width / 2) - scale * firstMatch.x;
            const ty = (height / 2) - scale * firstMatch.y;
            svg.transition().duration(450).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
          } else if (!q.length) {
            // si se borra la búsqueda, quitamos atenuación
            node.classed("dimmed", false);
            label.classed("dimmed", false);
          }
        });

        // Texto inicial limpio
        document.getElementById("content").textContent = "—";

      } catch (err) {
        document.getElementById("content").textContent = "Error cargando datos: " + err.message;
      }
    })();
  </script>
</body>
</html>
