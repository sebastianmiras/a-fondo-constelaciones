<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Constelación — Alejo Carpentier</title>
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:0; display:flex; height:100vh; }
    #viz { flex:1 1 auto; background:#fafafa; }
    #panel { width:340px; border-left:1px solid #e5e5e5; padding:16px; background:white; overflow:auto; }
    #panel h2 { font-size:18px; margin:0 0 6px; }
    #panel .meta { color:#666; font-size:12px; margin-bottom:8px; }
    #panel .ctx { white-space:pre-wrap; line-height:1.35; }

    .legend { position:absolute; left:10px; top:10px; background:rgba(255,255,255,.9); border:1px solid #e5e5e5; padding:8px; border-radius:6px; font-size:12px; }
    .search-box { position:absolute; right:360px; top:10px; background:white; border:1px solid #ccc; border-radius:6px; padding:4px; }

    .node { cursor:pointer; transition: opacity .2s ease; }
    .link { stroke:#bbb; stroke-opacity:.6; transition: opacity .2s ease; }
    .dimmed { opacity: .15; }
    /* CAMBIO (zoom): ocultamos el gráfico hasta tener el fit aplicado */
    .hidden { opacity: 0; }
  </style>
</head>
<body>
  <div id="viz"></div>
  <aside id="panel">
    <h2>Selecciona un nodo</h2>
    <div class="meta">Haz clic en una <strong>referencia</strong> para ver el contexto breve.</div>
    <div id="content" class="ctx">—</div>
    <div id="video-container" style="margin-top:16px;">
    <iframe width="100%" height="200"
      src="https://www.youtube.com/embed/inF8qRk4RDU?si=F0sJVRCcnjj_KqKr"
      title="Entrevista completa"
      frameborder="0"
      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen>
    </iframe>
  </div>
  </aside>

  <div class="legend">
    <strong>Categorías</strong><br/>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:green;margin-right:4px;"></span> Pensamiento y conocimiento</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:purple;margin-right:4px;"></span> Contexto socio-histórico</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:red;margin-right:4px;"></span> Personales y biográficas</div>
    <div><span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:orange;margin-right:4px;"></span> Culturales y artísticas</div>
  </div>

  <div class="search-box">
    <input type="text" id="search" placeholder="Buscar referencia..." />
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
    const width = window.innerWidth - 340, height = window.innerHeight;

    const categoryColorsExact = {
      "pensamiento y conocimiento": "green",
      "contexto socio-histórico": "purple",
      "contexto socio-historico": "purple",
      "personales y biográficas": "red",
      "personales y biograficas": "red",
      "culturales y artísticas": "orange",
      "culturales y artisticas": "orange"
    };
    const categoryColorsById = {
      "categoria_pensamiento_y_conocimiento": "green",
      "categoria_contexto_sociohistorico": "purple",
      "categoria_personales_y_biograficas": "red",
      "categoria_culturales_y_artisticas": "orange"
    };
    const blueRef = "#1f77b4";

    function norm(s){ return (s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"").toLowerCase().trim(); }
    function colorForCategory(d){
      const byLabel = categoryColorsExact[norm(d.label)];
      if (byLabel) return byLabel;
      if (d.id && categoryColorsById[d.id]) return categoryColorsById[d.id];
      const idn = norm(d.id||"");
      if (idn.includes("pensamiento") || idn.includes("conocimiento")) return "green";
      if (idn.includes("contexto") || idn.includes("socio") || idn.includes("histor")) return "purple";
      if (idn.includes("personal") || idn.includes("biogra")) return "red";
      if (idn.includes("cultur") || idn.includes("artist")) return "orange";
      return "#000";
    }
    function colorNode(d){
      if (d.type === "reference") return blueRef;
      if (d.type === "category") return colorForCategory(d);
      if (d.type === "author") return "#000";
      return "#999";
    }

    async function loadCsvSmart(url){
      const txt = await fetch(url, {cache:"no-store"}).then(r => {
        if(!r.ok) throw new Error(`HTTP ${r.status} al cargar ${url}`); return r.text();
      });
      const head = txt.split(/\r?\n/,1)[0] || "";
      const sep = (head.split(";").length > head.split(",").length) ? ";" : ",";
      return d3.dsvFormat(sep).parse(txt);
    }

    (async () => {
      try{
        let [nodes, links] = await Promise.all([
          loadCsvSmart("carpentier_nodos.csv"),
          loadCsvSmart("carpentier_aristas.csv")
        ]);

        const nodeById = new Map(nodes.map(d => [d.id, d]));
        links = links.filter(e => nodeById.has(e.source) && nodeById.has(e.target));
        links.forEach(e => { e.source = nodeById.get(e.source); e.target = nodeById.get(e.target); });

        // Nodo central autor
        const authorNode = { id:"autor", label:"Alejo Carpentier", type:"author" };
        nodes.push(authorNode);
        nodes.filter(n => n.type==="category").forEach(cat => links.push({source:authorNode, target:cat}));

        // CAMBIO (zoom): pre-layout OFF-SCREEN para evitar “saltos”
        // Ejecutamos una simulación rápida solo para calcular posiciones antes de pintar
        {
          const preNodes = nodes.map(d => ({...d}));
          const preLinks = links.map(l => ({source: preNodes[nodes.indexOf(l.source)], target: preNodes[nodes.indexOf(l.target)]}));
          const preSim = d3.forceSimulation(preNodes)
            .force("link", d3.forceLink(preLinks).id(d=>d.id).distance(l =>
              (l.source.type==="category" || l.target.type==="category") ? 130 : 90
            ).strength(0.35))
            .force("charge", d3.forceManyBody().strength(-280))
            .force("center", d3.forceCenter(width/2, height/2))
            .force("collision", d3.forceCollide().radius(d => d.type==="category" ? 42 : (d.type==="author" ? 52 : 18)).strength(0.9))
            .stop();
          for (let i=0; i<250; i++) preSim.tick();   // ~250 iteraciones “rápidas”

          // Copiamos posiciones a los nodos reales antes de pintar
          preNodes.forEach((pn, i) => { nodes[i].x = pn.x; nodes[i].y = pn.y; });
        }

        const svg = d3.select("#viz").append("svg").attr("width", width).attr("height", height);
        const g = svg.append("g").classed("hidden", true); // CAMBIO (zoom): oculto hasta aplicar fit

        // Flechas
        svg.append("defs").selectAll("marker")
          .data(["arrow"]).join("marker")
          .attr("id","arrow").attr("viewBox","0 -5 10 10")
          .attr("refX",14).attr("refY",0)
          .attr("markerWidth",6).attr("markerHeight",6)
          .attr("orient","auto")
          .append("path").attr("d","M0,-5L10,0L0,5").attr("fill","#bbb");

        const link = g.append("g")
          .selectAll("line").data(links).join("line")
          .attr("class","link")
          .attr("stroke","#bbb").attr("stroke-opacity",0.6)
          .attr("marker-end","url(#arrow)");

        const node = g.append("g")
          .selectAll("circle").data(nodes).join("circle")
          .attr("class", d => "node " + d.type)
          .attr("r", d => d.type==="category" ? 20 : (d.type==="author" ? 30 : 8))
          .attr("fill", d => colorNode(d))
          .call(d3.drag()
            .on("start", (event,d) => { if(!event.active) sim.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
            .on("drag",  (event,d) => { d.fx=event.x; d.fy=event.y; })
            .on("end",   (event,d) => { if(!event.active) sim.alphaTarget(0); d.fx=null; d.fy=null; })
          )
          .on("click", (event,d) => showPanel(d));

        const label = g.append("g")
          .selectAll("text").data(nodes).join("text")
          .text(d => d.label)
          .attr("dy", d => d.type==="category" ? -25 : (d.type==="author" ? -35 : -12))
          .attr("font-size", d => d.type==="category" ? 14 : (d.type==="author" ? 18 : 11))
          .attr("text-anchor","middle").attr("fill","#333");

        // Simulación “en vivo” (suave, ya parte del pre-layout)
        const sim = d3.forceSimulation(nodes)
          .force("link", d3.forceLink(links).id(d=>d.id).distance(l =>
            (l.source.type==="category" || l.target.type==="category") ? 130 : 90
          ).strength(0.35))
          .force("charge", d3.forceManyBody().strength(-280))
          .force("center", d3.forceCenter(width/2, height/2))
          .force("collision", d3.forceCollide().radius(d => d.type==="category" ? 42 : (d.type==="author" ? 52 : 18)).strength(0.9));

        sim.on("tick", () => {
          link.attr("x1", d=>d.source.x).attr("y1", d=>d.source.y)
              .attr("x2", d=>d.target.x).attr("y2", d=>d.target.y);
          node.attr("cx", d=>d.x).attr("cy", d=>d.y);
          label.attr("x", d=>d.x).attr("y", d=>d.y);
        });

        // CAMBIO (zoom): zoom libre + FIT INICIAL SOLO al componente principal (ignorando huérfanas)
        const zoom = d3.zoom().scaleExtent([0.2, 2.2]).on("zoom", (event) => g.attr("transform", event.transform));
        svg.call(zoom);

        // Encuentra el componente conectado al autor (autor→categorías→referencias)
        function mainComponentNodes(){
          const adj = new Map(nodes.map(n => [n.id, []]));
          links.forEach(l => { adj.get(l.source.id).push(l.target.id); adj.get(l.target.id).push(l.source.id); });
          const visited = new Set(); const stack = ["autor"];
          while (stack.length){
            const u = stack.pop();
            if (visited.has(u)) continue;
            visited.add(u);
            (adj.get(u)||[]).forEach(v => { if(!visited.has(v)) stack.push(v); });
          }
          return new Set([...visited]); // ids
        }

        // Aplica fit a ese componente y muestra el gráfico sin “saltos”
        (function initialFit(){
          const ids = mainComponentNodes();
          // clona posiciones para bbox del componente
          const comp = g.append("g").attr("visibility","hidden");
          const tmp = comp.selectAll("circle").data(nodes.filter(n => ids.has(n.id))).join("circle")
                          .attr("cx", d=>d.x).attr("cy", d=>d.y).attr("r", 1);
          const box = comp.node().getBBox();
          comp.remove();

          if (box.width && box.height){
            const margin = 100;
            const sx = (width  - margin) / box.width;
            const sy = (height - margin) / box.height;
            let k = Math.min(sx, sy);
            k = Math.min(k, 0.85); // no acercar demasiado
            const tx = (width/2)  - k * (box.x + box.width/2);
            const ty = (height/2) - k * (box.y + box.height/2);
            svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(k));
          }
          g.classed("hidden", false); // mostrar ya encuadrado
        })();

        // Panel
        function showPanel(d){
          const panel = document.getElementById("content");
          if (d.type === "reference") {
            const ctx = (d.note && d.note.trim()) ? d.note : "Sin contexto breve disponible.";
            panel.innerHTML = `<strong>${escapeHtml(d.label||"Referencia")}</strong>\n\n${escapeHtml(ctx)}`;
          } else {
            panel.innerHTML = `<strong>${escapeHtml(d.label||"Categoría")}</strong>`;
          }
        }
        function escapeHtml(s){ return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

        // Búsqueda (atenúa no-coincidentes; mantiene colores; centra en primer match)
        const searchInput = document.getElementById("search");
        searchInput.addEventListener("input", () => {
          const q = norm(searchInput.value);
          let firstMatch = null;
          node.classed("dimmed", false); label.classed("dimmed", false); link.classed("dimmed", false);
          if (!q.length) return;

          const matchSet = new Set();
          node.each(d => { const hit = (d.type==="reference") && norm(d.label).includes(q); if (hit) { matchSet.add(d.id); if(!firstMatch) firstMatch = d; } });
          node.classed("dimmed", d => d.type==="reference" ? !matchSet.has(d.id) : false);
          label.classed("dimmed", d => d.type==="reference" ? !matchSet.has(d.id) : false);
          link.classed("dimmed", e => !(matchSet.has(e.source.id) || matchSet.has(e.target.id)));

          if (firstMatch) {
            const current = d3.zoomTransform(svg.node());
            const scale = Math.min(2.0, Math.max(0.9, current.k));
            const tx = (width/2)  - scale * firstMatch.x;
            const ty = (height/2) - scale * firstMatch.y;
            svg.transition().duration(450).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
          }
        });

        document.getElementById("content").textContent = "—";

      }catch(err){
        document.getElementById("content").textContent = "Error cargando datos: " + err.message;
      }
    })();
  </script>
</body>
</html>
